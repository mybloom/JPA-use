# JPA활용1

- 인프런 김영한 JPA활용1을 보고 정리한 내용입니다.

## chap2 프로젝트 환경 설정

### datasource decorator

- ?로 표시되는 쿼리 파라미터를 실제 값이 적용된 상태로 보여주는 datasource decorator는 성능저하의 우려가 있으므로 
실서버 사용시에는 성능테스트 후 사용하거나 개발서버에서만 사용한다.
- 해당 프로젝트에서는 p6spy를 사용.

## chap3 도메인 분석 설계

- p18,p19를 토대로 엔티티 클래스 개발하기 
- Member:Order = `일대다 양방향` 매핑
- [] 일대다 양방향 매핑 다시 보기 
- 외래키 값을 업데이트 치는 것은 누가? 
  - 둘 중에 하나를 주인이라는 개념으로 잡아서 변경 주체 설정

> 외래키 생성여부 
- 시스템마다 상황마다 다르다
- 정확성보다 잘 서비스 되는게 중요하면 외래키 빼고, index만 잘 걸어주면 되고
- 돈과 관련되고 데이터의 정합성이 중요하면 외래키 거는 것을 고민해야 한다.

> getter, setter
- 모두 제공하지 않고 꼭 필요한 별도의 메서드 제공이 이상적
- getter: 실무에서는 엔티티의 데이터는 조회할 일이 너무 많아서 getter는 모두 열어 두는 것이 편리
- setter: 변경지점이 명확하게 변경용 비지니스 메서드를 별도로 제공하는 것이 유지보수 측면에서 좋다.
  - 변경포인트를 많이 두지 않는다.

> 테이블 설계
- 단순히 id로 컬럼을 주면 조인할 때나 사용할 때 명확하지 않아서 `테이블명_id`로 주는 것이 관례상 편하다.

> 주소 값 타입
- 예시) Adderess 객체 
- 값타입은 기본적으로 불변 객체로 설계해야 한다. 
- 그러므로 Getter만 제공한다.
- JPA스펙상 엔티티나 임베디드 타입은 기본생성자를 제공한다.(public 또는 protected로 설정)
- JPA 구현 라이브러리가 객체를 생성할 때 리플렉션,프록시 같은 기술을 사용할 수 있도록 지원해야 하므로

### 엔티티 설계시 주의점

- 즉시로딩(EAGER)은 어떤 SQL이 실행될지 예측이 어렵다. 그리고 JPQL을 실행할 때 연관관계가 즉시로딩으로 되어 있으면 쿼리가 N+1개 수행된다. 
- 컬렉션은 필드에 추가한다. `List<Order> orders = new ArrayList<>();`
  - NPE 체크하지 않아도 되고,
  - 하이버네이트가 엔티티를 영속화할 때 컬렉션을 한번 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 
  - 하이버네이트가 원하는 매커니즘으로 동작하게 하기 위해 컬렉션을 가급적 변경하지 않는다. 

> 영속성 전이 cascade
- order 저장하면 orderItems도 같이 persist된다.
- @OneToMany(mappedBy = "order", cascade = CascadeType.ALL) 
- []  cascade는 주인에게 해야 할까? 거울에게 해야할까?

---

## chap4 애플리케이션 구현 준비

> 애플리케이션 아키텍쳐
- 계층형 구조 사용
  - controller, web : 웹계층
  - service : 비즈니스 로직, 트랜잭션 처리
  - repository : JPA를 직접 사용하는 계층, 엔티티 매니저 사용
  - domain : 엔티티가 모여 있는 계층, 모든 계층에서 사용
- 패키지 구조
  - 컨트롤러에서 repository바로 접근 할 수 있는 구조로 갈 예정
  - 방향은 단방향으로 
- **개발순서**
  - 웹 환경을 제외한 계층을 먼저 개발 : service, repository를 먼저 개발 후 test로 검증
  - 웹, Controller는 그 다음 개발
